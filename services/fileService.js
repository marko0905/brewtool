// brewtool/services/fileService.js

import * as fs from 'node:fs/promises';
import * as os from 'node:os';
import * as path from 'node:path';
import { getInstalledPackages } from './brewServices.js';

// Define the path for the config directory and brewfile
const CONFIG_DIR = path.join(os.homedir(), '.config', 'brewtool');
const BREWFILE_PATH = path.join(CONFIG_DIR, 'brewfile');

/**
 * Check if a file is a symlink
 * @param {string} filePath - Path to the file to check
 * @returns {Promise<boolean>} True if the file is a symlink
 */
async function isSymlink(filePath) {
  try {
    const stats = await fs.lstat(filePath);
    return stats.isSymbolicLink();
  } catch (err) {
    return false;
  }
}

/**
 * If file is a symlink, get the target path
 * @param {string} filePath - Path to the symlink
 * @returns {Promise<string|null>} Target path or null if not a symlink
 */
async function getSymlinkTarget(filePath) {
  try {
    if (await isSymlink(filePath)) {
      return await fs.readlink(filePath);
    }
    return null;
  } catch (err) {
    return null;
  }
}

/**
 * Ensure the config directory exists
 * @returns {Promise<boolean>} True if directory exists or was created successfully
 */
async function ensureConfigDir() {
  try {
    try {
      await fs.access(CONFIG_DIR);
      // Directory exists
      return true;
    } catch (err) {
      // Directory doesn't exist, create it
      await fs.mkdir(CONFIG_DIR, { recursive: true });
      return true;
    }
  } catch (err) {
    console.error('Error ensuring config directory exists:', err);
    return false;
  }
}

/**
 * Check if the brewfile exists
 * @returns {Promise<boolean>} True if brewfile exists
 */
async function checkBrewfileExists() {
  try {
    await fs.access(BREWFILE_PATH);
    return true;
  } catch (err) {
    return false;
  }
}

/**
 * Generate brewfile content from installed packages
 * @returns {Promise<string>} Brewfile content
 */
async function generateBrewfileContent() {
  const installedPackages = await getInstalledPackages();
  
  let content = '# Brewfile generated by BrewTool\n\n';
  
  installedPackages.forEach(pkg => {
    content += `brew \"${pkg.name}\"\n`;
  });
  
  return content;
}

/**
 * Create a new brewfile with installed packages
 * @returns {Promise<{success: boolean, message: string}>} Result of the operation
 */
async function createBrewfile() {
  try {
    await ensureConfigDir();
    
    const content = await generateBrewfileContent();
    await fs.writeFile(BREWFILE_PATH, content, 'utf8');
    
    return {
      success: true,
      message: 'Brewfile created successfully'
    };
  } catch (err) {
    return {
      success: false,
      message: `Failed to create Brewfile: ${err.message || 'Unknown error'}`
    };
  }
}

/**
 * Read and parse the brewfile
 * @returns {Promise<string[]>} Array of package names from brewfile
 */
async function readBrewfile() {
  try {
    const content = await fs.readFile(BREWFILE_PATH, 'utf8');
    
    // Extract package names from the brewfile
    const lines = content.split('\n');
    const packages = [];
    
    for (const line of lines) {
      // Match brew "package_name" or brew 'package_name'
      const match = line.match(/^\s*brew\s+['"]([^'"]+)['"]/);
      if (match) {
        packages.push(match[1]);
      }
    }
    
    return packages;
  } catch (err) {
    console.error('Error reading brewfile:', err);
    return [];
  }
}

/**
 * Update the brewfile to match installed packages
 * @returns {Promise<{success: boolean, message: string}>} Result of the operation
 */
async function updateBrewfile() {
  try {
    await ensureConfigDir();
    
    const exists = await checkBrewfileExists();
    if (!exists) {
      return await createBrewfile();
    }
    
    const content = await generateBrewfileContent();
    await fs.writeFile(BREWFILE_PATH, content, 'utf8');
    
    return {
      success: true,
      message: 'Brewfile updated successfully'
    };
  } catch (err) {
    return {
      success: false,
      message: `Failed to update Brewfile: ${err.message || 'Unknown error'}`
    };
  }
}

/**
 * Check if the brewfile is in sync with installed packages
 * @returns {Promise<boolean>} True if brewfile is up to date
 */
async function isBrewfileUpToDate() {
  try {
    const exists = await checkBrewfileExists();
    if (!exists) {
      return false;
    }
    
    const brewfilePackages = await readBrewfile();
    const installedPackages = await getInstalledPackages();
    
    const installedSet = new Set(installedPackages.map(pkg => pkg.name));
    const brewfileSet = new Set(brewfilePackages);
    
    // Check that all installed packages are in brewfile
    for (const pkg of installedSet) {
      if (!brewfileSet.has(pkg)) {
        return false;
      }
    }
    
    // Check that all brewfile packages are installed
    for (const pkg of brewfileSet) {
      if (!installedSet.has(pkg)) {
        return false;
      }
    }
    
    return true;
  } catch (err) {
    console.error('Error checking if brewfile is up to date:', err);
    return false;
  }
}

/**
 * Get packages that would be affected by reinstalling from brewfile
 * @returns {Promise<{toInstall: string[], toRemove: string[]}>} Lists of packages to install and remove
 */
async function getBrewfileSyncChanges() {
  try {
    const exists = await checkBrewfileExists();
    if (!exists) {
      return {
        toInstall: [],
        toRemove: []
      };
    }
    
    // Get brewfile packages
    const brewfilePackages = await readBrewfile();
    
    // Get currently installed packages
    const installedPackages = await getInstalledPackages();
    const installedNames = installedPackages.map(pkg => pkg.name);
    
    // Find packages to install (in brewfile but not installed)
    const toInstall = brewfilePackages.filter(name => !installedNames.includes(name));
    
    // Find packages to remove (installed but not in brewfile)
    const toRemove = installedNames.filter(name => !brewfilePackages.includes(name));
    
    return {
      toInstall,
      toRemove
    };
  } catch (err) {
    console.error('Error calculating brewfile sync changes:', err);
    return {
      toInstall: [],
      toRemove: []
    };
  }
}

/**
 * Perform full sync with brewfile (install missing packages, remove extra packages)
 * @param {boolean} dryRun - If true, just return what would happen without making changes
 * @returns {Promise<{success: boolean, message: string, installed: string[], removed: string[]}>} Result of the operation
 */
async function syncWithBrewfile(dryRun = false) {
  try {
    const exists = await checkBrewfileExists();
    if (!exists) {
      return {
        success: false,
        message: 'Brewfile does not exist',
        installed: [],
        removed: []
      };
    }
    
    // Get changes that would be made
    const { toInstall, toRemove } = await getBrewfileSyncChanges();
    
    // If dry run, just return what would happen
    if (dryRun) {
      return {
        success: true,
        message: 'Dry run completed',
        installed: toInstall,
        removed: toRemove
      };
    }
    
    // Apply changes
    const installResults = [];
    const removeResults = [];
    
    // Install packages from brewfile
    for (const packageName of toInstall) {
      try {
        const proc = Bun.spawn(["brew", "install", packageName], {
          stdout: "pipe",
          stderr: "pipe",
        });
        
        const exitCode = await proc.exited;
        
        if (exitCode === 0) {
          installResults.push({ name: packageName, success: true });
        } else {
          const stderr = await new Response(proc.stderr).text();
          installResults.push({ 
            name: packageName, 
            success: false, 
            error: stderr 
          });
        }
      } catch (err) {
        installResults.push({ 
          name: packageName, 
          success: false, 
          error: err.message 
        });
      }
    }
    
    // Remove packages not in brewfile
    for (const packageName of toRemove) {
      try {
        const proc = Bun.spawn(["brew", "uninstall", packageName], {
          stdout: "pipe",
          stderr: "pipe",
        });
        
        const exitCode = await proc.exited;
        
        if (exitCode === 0) {
          removeResults.push({ name: packageName, success: true });
        } else {
          const stderr = await new Response(proc.stderr).text();
          removeResults.push({ 
            name: packageName, 
            success: false, 
            error: stderr 
          });
        }
      } catch (err) {
        removeResults.push({ 
          name: packageName, 
          success: false, 
          error: err.message 
        });
      }
    }
    
    // Check if all operations succeeded
    const allInstallsSucceeded = installResults.every(r => r.success);
    const allRemovalsSucceeded = removeResults.every(r => r.success);
    const allSucceeded = allInstallsSucceeded && allRemovalsSucceeded;
    
    // Create result message
    let message = '';
    if (allSucceeded) {
      message = 'Successfully synced with Brewfile';
      if (installResults.length > 0) {
        message += ` (installed ${installResults.length} package(s)`;
        if (removeResults.length > 0) {
          message += `, removed ${removeResults.length} package(s))`;
        } else {
          message += ')';
        }
      } else if (removeResults.length > 0) {
        message += ` (removed ${removeResults.length} package(s))`;
      } else {
        message += ' (no changes needed)';
      }
    } else {
      message = 'Failed to fully sync with Brewfile. Some operations did not complete successfully.';
    }
    
    return {
      success: allSucceeded,
      message,
      installed: installResults.filter(r => r.success).map(r => r.name),
      removed: removeResults.filter(r => r.success).map(r => r.name)
    };
  } catch (err) {
    return {
      success: false,
      message: `Error syncing with Brewfile: ${err.message || 'Unknown error'}`,
      installed: [],
      removed: []
    };
  }
}

export {
  BREWFILE_PATH,
  checkBrewfileExists,
  createBrewfile,
  getBrewfileSyncChanges,
  getSymlinkTarget,
  syncWithBrewfile as installFromBrewfile, // Export syncWithBrewfile as installFromBrewfile
  isBrewfileUpToDate,
  isSymlink,
  readBrewfile,
  updateBrewfile
};
